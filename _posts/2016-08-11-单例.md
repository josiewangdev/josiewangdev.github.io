---
layout: post
title: 单例 · Singleton
tags: iOS
categories: Dev
description: The usage of single in Swift and Objective-C
---

#### Singleton in Objective-C ####
#### Objective-C 中的单例写法 ####

{% highlight objc %}
+ (instancetype)sharedInstance {
    static ClassName *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[ClassName alloc] init];
    });
    return sharedInstance;
}
{% endhighlight %}

---

#### Sigleton in Swift ####

In Swift, the lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as `dispatch_once` to make sure that the initialization is atomic. This enables a cool way to use `dispatch_once` in your code: just declare a global variable with an initializer and mark it private.

Also, we all know that the static variable still support the `dispatch_once` feature, Swift will implement `swift_once_block_invoke` when it is inited, so we can use a simpler way to implement singleton.

#### Swift 中的单例写法 ####

在Swift中，全局变量（还有结构体和枚举体的静态成员）的懒加载初始化方法会在其被访问的时候调用一次，类似于调用 `dispatch_once` 以保证其初始化的原子性。这样就有了一种很酷的 `dispatch_once` 方式：只声明一个全局变量和私有的初始化方法即可。

我们又已知静态类变量是支持 `dispatch_once` 特性的, Swift将会把静态变量的初始化包装在一次 `swift_once_block_invoke` 中，所以就有了一种更加简洁直观的单例写法。

---

{% highlight swift %}
//use global variable to implement singleton
private let sharedClassName = TheOneAndOnlyClass()
class TheOneAndOnlyClass {
    class var sharedInstance: TheOneAndOnlyClass {
        return sharedClassName
    }
}

{% endhighlight %}

{% highlight swift %}
//a more simpler way to implement singleton
class TheOneAndOnlyClass {
    static let sharedInstance = TheOneAndOnlyClass()
    private init() {} //This prevents others from using the default '()' initializer for this class.
}
{% endhighlight %}

---
