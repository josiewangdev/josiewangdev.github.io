---
layout: post
title: NSTimer内存管理 · NSTimer memory management
tags: iOS
categories: Dev
---

NSTimer will maintain a strong reference to the target, which can cause (especially in repeating timers) strong reference cycles (a.k.a. retain cycles). 

A common example of an unresolved strong reference cycle would be to have a UIViewController with a NSTimer property that repeats, but because the NSTimer has a strong reference to the UIViewController, the controller will end up being retained.

So, if you're keeping the NSTimer as an instance variable, then, yes, you should `invalidate` it, to resolve the strong reference cycle. 

If you're just calling the `scheduledTimerWithTimeInterval`, but not saving it to an instance variable, then your strong 
reference cycle will be resolved when the NSTimer is complete.

NSTimer会对其对象持有一个强引用，特别是在重复任务定时器中，很有可能产生引用循环。

一个强引用循环没法释放的例子就是，当一个 UIViewController 有一个重复任务的定时器，但是这个定时器又持有了一个对 UIViewController 的强引用，则这个视图控制器将无法被释放。

所以说，当你实例化了一个 NSTimer，你应该 `invalidate` (停止)它， 来解决强引用循环的问题。

如果你只是调用了 `scheduledTimerWithTimeInterval` 这个方法，但是并没有实例化定时器，那么你的定时器的强引用则会在 `NSTimer` 任务完成时被释放。

---