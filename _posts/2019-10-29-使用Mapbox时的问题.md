---
layout: post
title: 使用Mapbox时的问题
tags: Project
categories: Tech
cover: upload/blog_masonry_05.jpg
---

* Snapchat使用Mapbox时酷炫的地图UI效果让我萌生了在我们项目中也使用Mapbox去实现地图模块的想法，尤其是当了解到Mapbox可以只需要在Mapbox的Studio后台中编辑修改你的地图样式，无需更新前端线上已有app，地图的UI就能动态更新这个及其方便的特性。但是因为Mapbox使用的js语言与源生应用语言不同，以及它实现我们需要的Cluster聚合效果并不能满足我们的项目需求，还是遇到了一些问题，同时我也将解决方案一并记录下来。

<br>
### 项目实例

我们现在的项目中，有如下UI设计需求，地图上需要有多个Pin坐标，并且这些坐标是可以有聚合（Cluster）效果的，并且聚合时点击显示的数据展示页面与散开时点击的数据展示页面是不同的UI效果。

<img src="/images/mapbox/mapbox.gif" />

* Mapbox原生API实现聚合效果的方法

{% highlight swift %}
fileprivate func setupMapViewUI() {

    var annotations : [MGLPointFeature] = []
    for buyer in buyers {
        let annotation = MGLPointFeature()
        annotation.coordinate = CLLocationCoordinate2DMake(buyer.lastLatitude, buyer.lastLongitude)
        annotation.title = buyer.displayName
        annotations.append(annotation)
    }

    let source = MGLShapeSource(identifier: sourceReuseId, features: annotations, options: [.clustered: true, .clusterRadius: 30])
    mapView.style?.addSource(source)

    let iconImage = UIImage(named: "pinblue")
    mapView.style?.setImage(iconImage!.withRenderingMode(.alwaysOriginal), forName: "icon")

    let clusteredPinLayer = MGLSymbolStyleLayer(identifier: clusteredLayerReuseId, source: source)
    clusteredPinLayer.iconImageName = MGLStyleValue(rawValue: "icon")
    clusteredPinLayer.textColor = MGLStyleValue(rawValue: UIColor.white)
    clusteredPinLayer.textFontSize = MGLStyleValue(rawValue: NSNumber(value: 12))
    clusteredPinLayer.text = MGLStyleValue(rawValue: "{point_count}")
    clusteredPinLayer.predicate = NSPredicate(format: "%K == YES", "cluster")
    clusteredPinLayer.textOffset = MGLStyleValue(rawValue: NSValue.init(cgVector: CGVector(dx: 0, dy: -0.2)))
    mapView.style?.addLayer(clusteredPinLayer)

    let unclusteredPinLayer = MGLSymbolStyleLayer(identifier: unclusteredLayerReuseId, source: source)
    unclusteredPinLayer.iconImageName = MGLStyleValue(rawValue: "icon")
    unclusteredPinLayer.textColor = MGLStyleValue(rawValue: UIColor.white)
    unclusteredPinLayer.textFontSize = MGLStyleValue(rawValue: NSNumber(value: 12))
    unclusteredPinLayer.text = MGLStyleValue(rawValue: "1")
    unclusteredPinLayer.predicate = NSPredicate(format: "%K != YES", "cluster")
    unclusteredPinLayer.textOffset = MGLStyleValue(rawValue: NSValue.init(cgVector: CGVector(dx: 0, dy: -0.2)))
    mapView.style?.addLayer(unclusteredPinLayer)

}
{% endhighlight %}

这样的实现方法没有问题，但是在获取Cluter聚合的具体数据时，Mapbox便不能满足我们的需求了。因为它的API并没有能够让我们去解析每个聚合点内的具体数据到底是什么, 从而我没有办法展示下一页面的列表信息。
为解决这个问题，我使用了FBAnnotationClustering这个第三方开源库，该库实现了在苹果自带系统地图基础上的Cluster聚合数据效果。



当然，这个库支持的数据类型是iOS源生Mapkit所持有的数据类型，我在使用这个库的时候，还需将它改写成适用于Mapbox所持有的数据类型，在此就不赘述了，之后有时间我会将支持Mapbox的改写的代码放到Git仓库上。通过这个库的支持，用如下代码实现了最后我们UI所需要达到的效果。

* 基于Mapbox的FBAnnotationClustering库使用实现聚合效果的方法

{% highlight swift %}

//MARK: - MGLMapViewDelegate

func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? {

    var reuseId = ""

    if !annotation.isKind(of: GBBuyerPointAnnotation.self)  {

        reuseId = "Cluster"

        var clusterView = mapView.dequeueReusableAnnotationView(withIdentifier: reuseId)

        if clusterView == nil {
            clusterView = MGLAnnotationView(annotation: annotation, reuseIdentifier: reuseId)
        }else {
            clusterView?.annotation = annotation
        }

        for subview in (clusterView?.subviews)! {
            subview.removeFromSuperview()
        }

        let clusterAnnotations = annotation as! FBAnnotationCluster
        let firstAnnotation = clusterAnnotations.annotations.first as! GBBuyerPointAnnotation
        let clusterCountView = firstAnnotation.getClusteringView(clusterAnnotations.annotations.count)
        clusterView?.frame = CGRect(origin: (clusterView?.frame.origin)!, size: clusterCountView.frame.size)
        clusterView?.centerOffset = CGVector(dx: 0, dy: -clusterCountView.frame.size.height / 2.0)
        clusterView?.addSubview(clusterCountView)

        return clusterView

    } else {

        reuseId = "Pin"

        var pinView = mapView.dequeueReusableAnnotationView(withIdentifier: reuseId)

        if pinView == nil {
            pinView = MGLAnnotationView(annotation: annotation, reuseIdentifier: reuseId)
        }else {
            pinView?.annotation = annotation
        }

        let pinAnnotation = annotation as! GBBuyerPointAnnotation
        let pinImageView = pinAnnotation.getPinView()

        pinView?.frame = CGRect(origin: (pinView?.frame.origin)!, size: pinImageView.frame.size)
        pinView?.centerOffset = CGVector(dx: 0, dy: -pinImageView.frame.size.height / 2.0)
        pinView?.addSubview(pinImageView)

        return pinView

    }

}

{% endhighlight %}

{% highlight swift %}

fileprivate let clusteringManager = FBClusteringManager()

fileprivate func updateBuyerAnnotationsOnMapView(_ mapView: MGLMapView) {

    weak var weakSelf = self

    OperationQueue().addOperation ({

        let leftBottomPoint = MKMapPointForCoordinate(mapView.visibleCoordinateBounds.sw)
        let rightTopPoint = MKMapPointForCoordinate(mapView.visibleCoordinateBounds.ne)
        let visibleRectWidth = rightTopPoint.x - leftBottomPoint.x
        let scale = Double(mapView.bounds.size.width) / visibleRectWidth

        let visibleMapRect = MKMapRect(origin: MKMapPoint(x: leftBottomPoint.x, y: rightTopPoint.y), size: MKMapSize(width: visibleRectWidth, height: leftBottomPoint.y - rightTopPoint.y))

        let annotations = weakSelf?.clusteringManager.clusteredAnnotationsWithinMapRect(visibleMapRect, withZoomScale: scale)

        weakSelf?.clusteringManager.displayAnnotations(annotations!, onMapView: mapView)

    })

}

{% endhighlight %}

[[参考Github地址] (OC) FBAnnotationClustering](https://github.com/infinum/FBAnnotationClustering)

[[参考Github地址] (Swift) FBAnnotationClusteringSwift](https://github.com/ribl/FBAnnotationClusteringSwift)


