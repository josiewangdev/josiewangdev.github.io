<!DOCTYPE html>
<!--Post Page-->
<html>
	<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>
		
			离屏渲染
		
	</title>
	<meta name="description" content="离屏渲染">
	<link rel="preload" as="font" href="/fonts/Consolas.woff" type="font/woff2" crossorigin="anonymous">
	<link rel="preload" as="font" href="/fonts/Brat.woff" type="font/woff2" crossorigin="anonymous">
	<link rel="stylesheet" href="/css/main.css" />
  	<link rel="canonical" href="http://localhost:4000/dev/2019-05-26/off-screen-rendering">
</head>
	<body>
		<div class="post-container">
			<div class="sidebar">
				<div class="post-intro">
					<h2>离屏渲染</h2>
					<!-- <p></p> -->
					<span>2019.05</span>
				</div>
<!-- 				<nav id="lang-sel" >
				    <ul class="lang">
				        
				        
				        
				        <li class="masthead_menu-item visible-links">
					        <a href="/dev/2019-05-26/off-screen-rendering" class="enabled">中文 </a>|<a href="/en/dev/2019-05-26/off-screen-rendering"> Eng</a>
				        </li>
				        
				    </ul>
				 </nav> -->
			</div>
			<div class="post-content">
				<h2 id="离屏渲染">离屏渲染</h2>

<hr />

<h4 id="1-gpu屏幕渲染的两种方式">1. <a href="#p1">GPU屏幕渲染的两种方式</a></h4>
<h4 id="2-为什么要使用离屏渲染">2. <a href="#p2">为什么要使用离屏渲染？</a></h4>
<h4 id="3-离屏渲染的过程">3. <a href="#p3">离屏渲染的过程</a></h4>
<h4 id="4-界面卡顿的原因">4. <a href="#p4">界面卡顿的原因</a></h4>
<h4 id="5-会引发离屏渲染的操作">5. <a href="#p5">会引发离屏渲染的操作</a></h4>
<h4 id="6-圆角属性优化方案">6. <a href="#p6">圆角属性优化方案</a></h4>
<h4 id="7-阴影优化方案">7. <a href="#p7">阴影优化方案</a></h4>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p1">1. GPU屏幕渲染的两种方式</h4>
</blockquote>

<p><strong>当前屏幕渲染</strong></p>

<p>指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。</p>

<p><strong>离屏渲染</strong></p>

<p>指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。相比于当前屏幕渲染，离屏渲染的代价是很高的。</p>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p2">2. 为什么要使用离屏渲染？</h4>
</blockquote>

<p>当有些图层的属性混合效果受自身上下文，屏幕缓存等限制因素，不能直接绘制于屏幕上，需要在别的地方做额外的处理预合成，就使用到离屏渲染。意味着图层必须在被显示之前在一个屏幕外上下文中被渲染。</p>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p3">3. 离屏渲染的过程</h4>
</blockquote>

<p><strong>1).</strong> 创建一个新的缓冲区</p>

<p><strong>2).</strong> 多次切换上下文环境</p>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p4">4. 界面卡顿的原因</h4>
</blockquote>

<p>离屏渲染先是从当前屏幕（On-screen）切换到离屏（Off-screen），等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价。由于垂直同步的机制，如果在一个显示器的刷新时间内，GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p5">5. 会引发离屏渲染的操作</h4>
</blockquote>

<p><strong>1).</strong> 为图层设置遮罩（layer.mask), 将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</p>

<p><strong>2).</strong> 任何以CG开头的class</p>

<p><strong>3).</strong> 将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</p>

<p><strong>4).</strong> 为图层设置阴影（layer.shadow *）</p>

<p><strong>5).</strong> 为图层设置layer.shouldRasterize=true</p>

<p><strong>6).</strong> 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。</p>

<p><strong>7).</strong> 文本（任何种类，包括UILabel，CATextLayer，Core Text等）</p>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p6">6. 圆角属性优化方案</h4>
</blockquote>

<p>同时设置 <code class="highlighter-rouge">layer.cornerRadius</code> 和 <code class="highlighter-rouge">layer.masksToBounds</code> 会发生离屏渲染。</p>

<p>例如：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Set the rounded corners of the UIView - will not produce off-screen rendering</span>
<span class="k">self</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
 
<span class="c1">//  Set the rounded corners of the UIButton - generate off-screen rendering</span>
<span class="k">self</span><span class="o">.</span><span class="n">btn</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">self</span><span class="o">.</span><span class="n">btn</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="kt">YES</span><span class="p">;</span>
    
<span class="c1">//  Set the rounded corners of the UIImageView - generate off-screen rendering</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="kt">YES</span><span class="p">;</span>
</code></pre></div></div>

<p>优化方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  1. Load image</span>
<span class="kt">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UIImage</span> <span class="nv">imageNamed</span><span class="p">:</span><span class="s">@"1.png"</span><span class="p">];</span>
 
<span class="c1">//  2. Turn on bitmap context</span>
<span class="kt">UIGraphicsBeginImageContext</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">);</span>
    
<span class="c1">//  3. Set a circular clipping area</span>
<span class="kt">UIBezierPath</span> <span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UIBezierPath</span> <span class="nv">bezierPathWithRoundedRect</span><span class="p">:</span><span class="kt">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="nv">cornerRadius</span><span class="p">:</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">];</span>
<span class="c1">// Set the path to the crop area. Content beyond the crop area will be automatically cropped (the effect on the content drawn later, the context content already drawn will not be cropped)</span>
<span class="p">[</span><span class="n">path</span> <span class="n">addClip</span><span class="p">];</span>
    
<span class="c1">//  4. Draw the image into the context</span>
<span class="p">[</span><span class="n">image</span> <span class="nv">drawAtPoint</span><span class="p">:</span><span class="kt">CGPointZero</span><span class="p">];</span>
    
<span class="c1">//  5. Generate an image from the context</span>
<span class="kt">UIImage</span> <span class="o">*</span> <span class="n">newImage</span> <span class="o">=</span>  <span class="kt">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
    
<span class="c1">//  6. Close the context</span>
<span class="kt">UIGraphicsEndImageContext</span><span class="p">();</span>
    
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">newImage</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="p7">7. 阴影优化方案</h4>
</blockquote>

<p>使用 <code class="highlighter-rouge">ShadowPath</code> 而非设置 <code class="highlighter-rouge">shadowOffset</code> 等属性。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UIColor</span> <span class="n">grayColor</span><span class="p">]</span><span class="o">.</span><span class="kt">CGColor</span><span class="p">;</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">shadowOpacity</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">shadowRadius</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="kt">CGSizeMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  
<span class="c1">//  Set the path of the shadow</span>
<span class="kt">UIBezierPath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UIBezierPath</span> <span class="nv">bezierPathWithRect</span><span class="p">:</span><span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">bounds</span><span class="p">];</span>
<span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">shadowPath</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="kt">CGPath</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<p><br /></p>

<blockquote>
  <h4 id="参考链接">参考链接</h4>
</blockquote>

<ul>
  <li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li>
</ul>

			</div>
		</div>
		<!-- Scripts -->
<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/jquery.scrollex.min.js"></script>
<script type="text/javascript" src="/js/skel.min.js"></script>
<script type="text/javascript" src="/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>
<!-- <script type="text/javascript" src="/js/yall.min.js"></script> -->
<script src="https://cdn.jsdelivr.net/npm/intersection-observer@0.7.0/intersection-observer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@14.0.0/dist/lazyload.min.js"></script>
<script>
  // document.addEventListener("DOMContentLoaded", yall);
  var lazyLoadInstance = new LazyLoad({ elements_selector: ".lazy" });
</script>

	</body>
</html>